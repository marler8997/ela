const std = @import("std");
const Builder = std.build.Builder;
const Step = std.build.Step;
const StringHashMap = std.StringHashMap;

//const windowsopengl32 = @import("windowsopengl32.zig");
const gl = @import("gl.zig");

pub const OpenGlCodegenStep = struct {
    step: Step,
    b: *Builder,
    filename: []const u8,
    funcs: []const []const u8,
    pub fn init(b: *Builder, named: struct { filename: []const u8, funcs: []const []const u8 }) OpenGlCodegenStep {
        return .{
            .step = Step.init(.Custom, "generate OpenGL bindings", b.allocator, make),
            .b = b,
            .filename = named.filename,
            .funcs = named.funcs,
        };
    }
    fn make(step: *Step) anyerror!void {
        const self = @fieldParentPtr(OpenGlCodegenStep, "step", step);

        // TODO: check if the source needs to be regenerated???

        var build_root = try std.fs.cwd().openDir(self.b.build_root, .{});
        defer build_root.close();
        const file = try build_root.createFile(self.filename, .{});
        defer file.close();
        const writer = file.writer();
        try writer.writeAll(
            \\//! WARNING: This code is autogenerated from OpenGlCodegenStep in build.zig.
            \\const std = @import("std");
            \\const gl = @import("gl");
            \\
            \\pub const bits = gl.bits;
            \\pub const zig = gl.zig;
            \\
            \\usingnamespace gl.bits;
            \\
            \\pub fn loadRuntimeFuncs() ?gl.zig.LoadRuntimeFuncsError {
            \\    return gl.zig.loadRuntimeFuncs(runtimefuncs);
            \\}
            \\pub usingnamespace if (std.builtin.os.tag == .windows) struct {
        );

        // setup a lookup for the windows functions
        {
            // gather linkable and runtime function
            var linkable_funcs = std.ArrayList([]const u8).init(self.b.allocator);
            defer linkable_funcs.deinit();
            var runtime_funcs = std.ArrayList([]const u8).init(self.b.allocator);
            defer runtime_funcs.deinit();
            {
                const Nothing = struct {};
                var linkable_func_map = StringHashMap(Nothing).init(self.b.allocator);
                defer linkable_func_map.deinit();
                var runtime_func_map = StringHashMap(Nothing).init(self.b.allocator);
                defer runtime_func_map.deinit();
                inline for (@typeInfo(gl.windows).Struct.decls) |decl| {
                    try linkable_func_map.put(decl.name, .{});
                }
                inline for (@typeInfo(gl.windows.RuntimeFnTypes).Struct.decls) |decl| {
                    try runtime_func_map.put(decl.name, .{});
                }
                for (self.funcs) |func| {
                    if (linkable_func_map.get(func)) |_| {
                        try linkable_funcs.append(func);
                    } else if (runtime_func_map.get(func)) |_| {
                        try runtime_funcs.append(func);
                    } else {
                        std.debug.warn("Error: unknown OpenGL function '{}' added to OpenGlCodegenStep in build.zig\n", .{func});
                    }
                }
            }

            for (linkable_funcs.items) |func| {
                try writer.print("    pub const {s} = gl.windows.{s};\n", .{func, func});
            }
            try writer.print("    pub const runtimefuncs = struct {{\n", .{});
            for (runtime_funcs.items) |func| {
                // TODO: set to a function that asserts an error?
                try writer.print("        pub var {s} : gl.windows.RuntimeFnTypes.{s} = undefined;\n", .{func, func});
            }
            try writer.print("    }}; // end of runtimefuncs\n", .{});

            try writer.print("}} else struct {{ }}; // end of windows bindings\n", .{});
        }
    }
};

// TODO: I'm not using this anymore, but it should go somewhere, like standard lib
//const UpperFormatter = struct {
//    s: []const u8,
//    pub fn format(
//        self: @This(),
//        comptime fmt: []const u8,
//        options: std.fmt.FormatOptions,
//        writer: anytype,
//    ) std.os.WriteError!void {
//        var printed : usize = 0;
//        var i : usize = 0;
//        while (i < self.s.len) : (i += 1 ){
//            if (self.s[i] >= 'a' and self.s[i] <= 'z') {
//                if (i > printed)
//                    try writer.writeAll(self.s[printed .. i]);
//                try writer.writeByte(self.s[i] - ('a' - 'A'));
//                printed = i + 1;
//            }
//        }
//        if (i > printed)
//            try writer.writeAll(self.s[printed .. i]);
//    }
//};
//pub fn fmtUpper(s: []const u8) UpperFormatter {
//    return .{ .s = s };
//}
//